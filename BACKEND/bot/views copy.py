import os
import io
import json
import requests
import threading
import re
from openai import OpenAI
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse, HttpResponseBadRequest
from dotenv import load_dotenv
from decimal import Decimal
from django.db.models import Case, When
from .utils import search_similar_articles
from inventari.models import Article
from bot.models import Comanda, Usuari
from rest_framework import generics
from rest_framework.response import Response
from rest_framework import status
from .serializers import ComandaSerializer, UsuariSerializer, ArticleSerializer
# Carregar variables d'entorn
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Inicialitzar client OpenAI
openai = OpenAI(api_key=OPENAI_API_KEY)

# URLs de l'API de Telegram
TELEGRAM_URL = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
TELEGRAM_GETFILE_URL = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getFile"

# Estat intern per a comandes i conversa
pending_orders = {}        # chat_id -> Article object
pending_confirmations = {} # chat_id -> (Article object, quantity)
pending_selections = {}    # chat_id -> list[Article] for similar articles
chat_language = {}         # chat_id -> language code
conversation_history = {}  # chat_id -> list of messages
processed_update_ids = set()
update_lock = threading.Lock()

# System prompt per GPT-4o
SYSTEM_PROMPT = {
    "role": "system",
    "content": (
        "You are ShopMate, a professional, multilingual shopping assistant. "
        "Always ask and answer in the same language as the user‚Äôs last message. "
        "Use the user's first name (provided in the conversation context) naturally in your responses, such as starting sentences or within them. "
        "Follow this flow and output only JSON with keys: action, article, quantity, message, language.\n\n"
        "1. If no article is named in the conversation, set action=ask, article=null, quantity=null, and generate a natural and varied message asking for the item, such as 'What can I help you find today?' or 'Which product are you interested in purchasing?'\n"
        "2. When the user provides an article name, set action=search, article=<name>, quantity=null, and generate a message asking for the quantity, like 'How many <article> would you like?'\n"
        "3. When the user provides a numeric quantity, set action=confirm, article=<name>, quantity=<int>, and generate a confirmation message, such as 'Please confirm your purchase of <quantity> <article>.'\n"
        "4. If the user confirms, set action=order; if they decline, set action=cancel. For action=order, set message=null (the final message will be generated by the system). For action=cancel, generate a cancellation message.\n"
        "Remember to always output JSON with the required keys and ensure your messages are natural, polite, and helpful."
    )
}

def neteja_resposta(resposta: str) -> str:
    """
    Elimina qualsevol bloc de codi Markdown ``` o ```json```
    i retorna la cadena neta per fer json.loads().
    """
    #print(f"‚öôÔ∏è Cleaning response: {resposta!r}")
    resposta = re.sub(r'```(?:json)?\n?', '', resposta)
    resposta = re.sub(r'```', '', resposta)
    clean = resposta.strip()
    print(f"‚öôÔ∏è Cleaned response: {clean!r}")
    return clean

def call_openai(messages, response_format=None):
    kwargs = {
        "model": "gpt-4o-2024-08-06",
        "messages": messages,
        "temperature": 0.2,
    }
    if response_format:
        kwargs["response_format"] = response_format
    resp = openai.chat.completions.create(**kwargs)
    content = resp.choices[0].message.content
    print(f"‚öôÔ∏è OpenAI raw response: {content!r}")
    clean = neteja_resposta(content)
    return clean

def translate_message(message_template, lang, **kwargs):
    """
    Tradueix un missatge plantilla a l'idioma especificat utilitzant OpenAI.
    """
    message = message_template.format(**kwargs)
    prompt = f"Translate the following message to {lang}, but do not translate the product names: '{message}'"
    translated = call_openai([{"role": "user", "content": prompt}])
    return translated




def send_telegram_message(chat_id, text):
    print(f"üöÄ send_telegram_message -> chat_id: {chat_id}, text: {text}")
    try:
        requests.post(TELEGRAM_URL, json={"chat_id": chat_id, "text": text})
    except Exception as e:
        print(f"‚ö†Ô∏è Error sending message: {e}")

from django.db.models.functions import Trim

def buscar_article(descripcio):
    key = descripcio.strip().lower()
    print(f"üîç buscar_article -> key: {key}")
    try:
        art = Article.objects.annotate(trimmed_desc=Trim('DescripcionArticulo')).get(trimmed_desc__iexact=key)
        print(f"‚úÖ Article found: {art}")
        return art
    except Article.DoesNotExist:
        print(f"‚ùå Article.DoesNotExist for key: {key}")
        similar_ids = search_similar_articles(key)
        if similar_ids:
            similar_articles = Article.objects.filter(CodigoArticulo__in=similar_ids)
            print(f"üîç Found similar articles: {[a.DescripcionArticulo for a in similar_articles]}")
            return similar_articles
        else:
            print(f"‚ùå No similar articles found")
            return None
        
def actualitzar_unidades(article, quantitat):
    print(f"üì¶ Stock before: {article.Unidades}")
    article.Unidades -= quantitat
    article.save()
    print(f"üì¶ Stock after: {article.Unidades}")

def handle_voice_message(file_id):
    print(f"‚¨áÔ∏è Downloading voice file {file_id}")
    info = requests.get(TELEGRAM_GETFILE_URL, params={"file_id":file_id}).json().get('result', {})
    ogg = requests.get(f"https://api.telegram.org/file/bot{TELEGRAM_TOKEN}/{info.get('file_path')}").content
    print("üéß File downloaded, sending to Whisper")
    buf = io.BytesIO(ogg)
    buf.name = 'voice.ogg'
    resp = openai.audio.transcriptions.create(model='whisper-1', file=buf, response_format='text')
    print(f"üìù Transcription result: {resp}")
    return resp

def generar_comanda(article_id, preu_u, quantitat, user_id):
    from decimal import Decimal
    from bot.models import Usuari, Comanda
    from inventari.models import Article

    usuari_obj = Usuari.objects.get(pk=user_id)
    article_obj = Article.objects.get(pk=article_id)

    preu_u_dec = Decimal(str(preu_u))
    total = preu_u_dec * Decimal(quantitat)

    print(f"Creant comanda -> user:{usuari_obj}, article:{article_obj}, qty:{quantitat}, total:{total}")

    comanda = Comanda.objects.create(
        user=usuari_obj,
        article=article_obj,
        Quantitat=quantitat,
        PreuFinal=total
    )

    print(f"Comanda desada: {comanda}")
    return comanda

@csrf_exempt
def telegram_webhook(request):
    print(f"üöÄ Webhook hit with method {request.method}")
    if request.method != 'POST':
        print("‚ö†Ô∏è Invalid method, returning 400")
        return HttpResponseBadRequest("M√®tode no perm√®s")
    threading.Thread(target=process_update, args=(request.body,)).start()
    return JsonResponse({'status': 'received'})

def process_update(body):
    print(f"üîÑ process_update received body: {body}")
    try:
        data = json.loads(body)
    except json.JSONDecodeError:
        print(f"‚ö†Ô∏è Invalid JSON: {body}")
        return

    update_id = data.get('update_id')
    with update_lock:
        if update_id in processed_update_ids:
            print(f"‚ö†Ô∏è Duplicate update_id {update_id}")
            return
        processed_update_ids.add(update_id)

    msg = data.get('message', {})
    chat_id = msg.get('chat', {}).get('id')
    print(f"üë§ Chat ID: {chat_id}")
    if not chat_id:
        return
    
    # Guardar/Actualitzar dades de l'usuari
    user_data = msg.get('from', {})
    user_id = user_data.get('id')
    first_name = user_data.get('first_name', '')
    username = user_data.get('username')

    Usuari.objects.update_or_create(
        UserId=user_id,
        defaults={'FirstName': first_name, 'Username': username},
    )

    first_name = Usuari.objects.get(UserId=user_id).FirstName

    if 'voice' in msg:
        print("üé§ Voice message detected")
        user_text = handle_voice_message(msg['voice']['file_id']) or ''
    else:
        user_text = (msg.get('text') or '').strip()
    print(f"üí¨ User text: {user_text}")

    history = conversation_history.setdefault(chat_id, [])
    
    # Handle selection from similar articles
    if chat_id in pending_selections:
        selection = user_text.strip().lower()
        similar_articles = pending_selections[chat_id]
        if selection.isalpha() and selection in [chr(97+i) for i in range(len(similar_articles))]:
            index = ord(selection) - 97
            selected_article = similar_articles[index]
            history.append({"role": "user", "content": selected_article.DescripcionArticulo})
            pending_selections.pop(chat_id)
        else:
            invalid_message = translate_message(
                "Selecci√≥ inv√†lida. Si us plau, tria una lletra de la llista.",
                chat_language.get(chat_id, 'en')
            )
            send_telegram_message(chat_id, invalid_message)
            return
    else:
        history.append({"role": "user", "content": user_text})

    convo = [
        {"role": "system", "content": f"The user's name is {first_name}."},
        SYSTEM_PROMPT
    ] + history
    result = call_openai(convo, response_format={"type": "json_object"})

    if not result:
        error_message = translate_message(
            "Sorry, there was an internal error. Please try again.",
            chat_language.get(chat_id, 'en')
        )
        send_telegram_message(chat_id, error_message)
        return

    try:
        payload = json.loads(result)
        # Corregir el tipus de clau
        if "quuantity" in payload:
            payload["quantity"] = payload.pop("quuantity")
        print(f"‚úÖ Parsed payload: {payload}")
    except json.JSONDecodeError as e:
        print(f"‚ö†Ô∏è JSON decode error: {e}, result was: {result!r}")
        error_message = translate_message("Sorry, there was an internal error. Please try again.", chat_language.get(chat_id, 'en'))
        send_telegram_message(chat_id, error_message)
        return


    action = payload.get('action')
    article = payload.get('article')
    qty = payload.get('quantity')
    message = payload.get('message')
    lang = payload.get('language', chat_language.get(chat_id, 'en'))
    chat_language[chat_id] = lang

    # Handle actions and modify message if necessary
    if action == 'search' and article:
        art_obj = buscar_article(article)
        print(f"Tipo de art_obj: {type(art_obj)}")
        if isinstance(art_obj, Article):
            pending_orders[chat_id] = art_obj
            unit_price = art_obj.PVP
            message += f" {translate_message('The price per unit is {unit_price}.', lang, unit_price=unit_price)}"
        elif art_obj is None:
            error_message = translate_message("No he trobat '{article}'. Si us plau, comprova el nom o intenta amb un producte diferent.", lang, article=article)
            send_telegram_message(chat_id, error_message)
            conversation_history.pop(chat_id, None)
            return
        else:
            # Assegura't que art_obj √©s iterable abans de convertir-lo en llista
            if hasattr(art_obj, '__iter__'):
                similar_articles = list(art_obj)
                if not similar_articles:
                    error_message = translate_message("No he trobat articles similars per '{article}'.", lang, article=article)
                    send_telegram_message(chat_id, error_message)
                    return
                options = [f"¬∑üõçÔ∏è{chr(97+i)}) {a.DescripcionArticulo}\n" for i, a in enumerate(similar_articles)]
                suggestion_message = translate_message(
                    "No he trobat '{article}', per√≤ aqu√≠ tens productes similars:\n{options}\nSi us plau, selecciona una lletra (a, b, c, etc.).",
                    lang,
                    article=article,
                    options="\n".join(options)
                )
                send_telegram_message(chat_id, suggestion_message)
                pending_selections[chat_id] = similar_articles
                return
            else:
                print(f"Error: art_obj no √©s iterable. Tipus: {type(art_obj)}")
                error_message = translate_message("Error intern. Si us plau, intenta de nou.", lang)
                send_telegram_message(chat_id, error_message)
                return
            
            
    elif action == 'confirm' and chat_id in pending_orders and isinstance(qty, int):
        art_obj = pending_orders[chat_id]
        if isinstance(art_obj, Article):
            total_price = art_obj.PVP * qty
            message += f" {translate_message('Total price: {total_price}.', lang, total_price=total_price)}"
            pending_confirmations[chat_id] = (art_obj, qty)
        else:
            error_message = translate_message("No exact article found for confirmation.", lang)
            send_telegram_message(chat_id, error_message)
            return
    elif action == 'order':
        if chat_id in pending_confirmations:
            art_obj, qty = pending_confirmations[chat_id]
            if isinstance(art_obj, Article):
                if art_obj.Unidades >= qty:
                    actualitzar_unidades(art_obj, qty)
                    generar_comanda(art_obj.CodigoArticulo, art_obj.PVP, qty, user_id)
                    total_price = art_obj.PVP * qty
                    success_message = translate_message(
                        "Your order of {qty} {article} has been placed successfully. Total price: {total_price}. Thank you, {first_name}!",
                        lang,
                        qty=qty,
                        article=art_obj.DescripcionArticulo,
                        total_price=total_price,
                        first_name=first_name
                    )
                    send_telegram_message(chat_id, success_message)
                else:
                    out_of_stock_message = translate_message(
                        "Sorry, there is not enough stock for {article}.",
                        lang,
                        article=art_obj.DescripcionArticulo
                    )
                    send_telegram_message(chat_id, out_of_stock_message)
            else:
                error_message = translate_message("No exact article found to process the order.", lang)
                send_telegram_message(chat_id, error_message)
            # Clean up
            pending_confirmations.pop(chat_id, None)
            pending_orders.pop(chat_id, None)
            conversation_history.pop(chat_id, None)
            chat_language.pop(chat_id, None)
            return
        else:
            error_message = translate_message("No pending order to process.", lang)
            send_telegram_message(chat_id, error_message)
            return
    elif action == 'cancel':
        cancel_message = translate_message("Your order has been cancelled.", lang)
        send_telegram_message(chat_id, cancel_message)
        # Clean up
        pending_confirmations.pop(chat_id, None)
        pending_orders.pop(chat_id, None)
        conversation_history.pop(chat_id, None)
        chat_language.pop(chat_id, None)
        return

    # For 'ask', 'search', 'confirm', send the message
    if action in ['ask', 'search', 'confirm']:
        send_telegram_message(chat_id, message)
        history.append({"role": "assistant", "content": message})

class UsuariListAPIView(generics.ListAPIView):
    queryset = Usuari.objects.all()
    serializer_class = UsuariSerializer

class ComandaListAPIView(generics.ListAPIView):
    queryset = Comanda.objects.all()
    serializer_class = ComandaSerializer
    
class ComandaDetailAPIView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Comanda.objects.all()
    serializer_class = ComandaSerializer
    lookup_field = 'ComandaId'

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        article = instance.article
        article.Unidades += instance.Quantitat
        article.save()
        self.perform_destroy(instance)
        return Response(status=status.HTTP_204_NO_CONTENT)