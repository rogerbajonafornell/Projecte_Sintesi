import os
import json
import logging
import requests
import subprocess
import threading
import time
import re
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse, HttpResponseBadRequest
from dotenv import load_dotenv

from .whisper_service import transcribe_audio
from inventari.models import Article

# --- Configuraci√≥ de logging per depuraci√≥ ---
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger(__name__)

# Carregar variables d'entorn
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
MISTRAL_API_KEY = os.getenv("MISTRAL_API_KEY")

# URLs de l'API de Telegram
TELEGRAM_URL = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
TELEGRAM_GETFILE_URL = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getFile"

# Endpoint de Mistral
MISTRAL_API_URL = "https://api.mistral.ai/v1/chat/completions"

# Estat intern per a comandes i confirmacions
pending_orders = {}        # chat_id -> article_desc
pending_confirmations = {} # chat_id -> (Article, quantity)

# Deduplciaci√≥ d'updates
processed_update_ids = set()
update_lock = threading.Lock()

# Prompt de sistema per donar control a la IA
SYSTEM_PROMPT = {
    "role": "system",
    "content": (
        "Ets ShopMate, un assistent de compres conversacional. "
        "Segueix sempre aquest flux:\n"
        "1Ô∏è‚É£ Si NO s'ha definit `article`, pregunta a l'usuari quin article vol (action=ask, article=null, quantity=null).\n"
        "2Ô∏è‚É£ Quan l'usuari respon un nom d'article, normalitza (min√∫scula, singular) i retorna action=search, article=<nom>, quantity=null i un `message` en llenguatge natural: \"Quantes unitats de <article> vols?\".\n"
        "3Ô∏è‚É£ Si s'ha definit `article` i l'usuari respon amb una quantitat num√®rica, retorna action=confirm, article=<nom>, quantity=<int> i un `message`: \"Vols confirmar la compra de <quantity> <article>?\".\n"
        "4Ô∏è‚É£ Si l'usuari confirma, retorna action=order, article=<nom>, quantity=<int> i un `message` de confirmaci√≥. Si cancel¬∑la, action=cancel.\n"
        "üîÑ Mantingues sempre l'idioma de l'√∫ltim missatge de l'usuari i posa'l a `language`.\n"
        "üîç No preguntis mai el ‚Äútipus‚Äù d'article, nom√©s busca el nom proporcionat.\n"
        "üì¶ Retorna **exclusivament** un JSON amb claus: action ‚àà {ask,search,confirm,order,cancel}, article: string|null, quantity: int|null, message: string, language: string.\n"
        "\n"
        "### Exemples **few‚Äëshot**\n"
        "# Example 1: l'usuari comen√ßa\n"
        "User: ‚ÄúBon dia‚Äù\n"
        "Assistant:\n"
        "{\n"
        "  \"action\": \"ask\", \"article\": null, \"quantity\": null,\n"
        "  \"message\": \"Qu√® vols comprar avui?\", \"language\": \"ca\"\n"
        "}\n"
        "# Example 2: l'usuari indica article\n"
        "User: ‚ÄúVull gomes‚Äù\n"
        "Assistant:\n"
        "{\n"
        "  \"action\": \"search\", \"article\": \"goma\", \"quantity\": null,\n"
        "  \"message\": \"Quantes unitats de goma vols?\", \"language\": \"ca\"\n"
        "}\n"
        "# Example 3: l'usuari respon quantitat\n"
        "User: ‚Äú2‚Äù\n"
        "Assistant:\n"
        "{\n"
        "  \"action\": \"confirm\", \"article\": \"goma\", \"quantity\": 2,\n"
        "  \"message\": \"Vols confirmar la compra de 2 gomes?\", \"language\": \"ca\"\n"
        "}\n"
    )
}


@csrf_exempt
def telegram_webhook(request):
    if request.method != 'POST':
        return HttpResponseBadRequest("M√®tode no perm√®s")
    threading.Thread(target=process_update, args=(request.body,)).start()
    return JsonResponse({'status': 'received'})


def call_mistral(messages):
    data = {
        "model": "mistral-small",
        "messages": messages,
        "temperature": 0.2,
        "response_format": {"type": "json_object"}
    }
    resp = requests.post(
        MISTRAL_API_URL,
        headers={"Authorization": f"Bearer {MISTRAL_API_KEY}", "Content-Type": "application/json"},
        json=data
    )
    logger.debug("Mistral status %s: %s", resp.status_code, resp.text)
    if resp.status_code != 200:
        raise RuntimeError("Mistral error: %s" % resp.text)
    return resp.json()["choices"][0]["message"]["content"]


def process_update(body):
    try:
        data = json.loads(body)
    except json.JSONDecodeError:
        logger.error("JSON no v√†lid al webhook: %s", body)
        return

    update_id = data.get('update_id')
    with update_lock:
        if update_id in processed_update_ids:
            logger.debug("Ignorant update_id duplicat: %s", update_id)
            return
        processed_update_ids.add(update_id)

    msg = data.get('message', {})
    chat_id = msg.get('chat', {}).get('id')

    # Gestionar veu
    if 'voice' in msg:
        transcription, err = handle_voice_message(msg['voice']['file_id'])
        if transcription is None:
            send_telegram_message(chat_id, err)
            return
        user_text = transcription
    else:
        user_text = (msg.get('text') or '').strip()

    # Construir conversa per Mistral
    convo = [SYSTEM_PROMPT, {"role": "user", "content": user_text}]
    try:
        result = call_mistral(convo)
    except Exception as e:
        logger.error("Error cridant Mistral: %s", e)
        send_telegram_message(chat_id, "Error amb la IA, torna-ho a intentar.")
        return

    try:
        payload = json.loads(result)
        # Si la IA retorna una llista, agafem el primer element
        if isinstance(payload, list) and payload:
            payload = payload[0]
    except json.JSONDecodeError:
        logger.error("Resposta inv√†lida de la IA: %s", result)
        send_telegram_message(chat_id, "Resposta inv√†lida de la IA.")
        return

    action = payload.get('action')
    article = payload.get('article')
    qty = payload.get('quantity')
    message = payload.get('message')
    lang = payload.get('language')

    # Enviar missatge generat per la IA
    send_telegram_message(chat_id, message)

    # Executar accions backend si cal
    if action == 'search' and article:
        art = buscar_article(article)
        if art:
            # Preguntar quantitats de manera natural
            send_telegram_message(chat_id, f"Quantes unitats de '{art.DescripcionArticulo}' vols?")
            pending_orders[chat_id] = art.DescripcionArticulo
        else:
            send_telegram_message(chat_id, f"Ho sento, no trobo l'article '{article}'.")

    elif action == 'order' and article and isinstance(qty, int):
        art = buscar_article(article)
        if art and art.Unidades >= qty:
            actualitzar_unidades(art, qty)
            send_telegram_message(chat_id, f"Compra feta: {qty}√ó '{art.DescripcionArticulo}'. Gr√†cies! üòä")
        elif art and art.Unidades == 0:
            send_telegram_message(chat_id, f"Ho sento, l'article '{art.DescripcionArticulo}' est√† esgotat.")
        else:
            send_telegram_message(chat_id, f"Nom√©s queden {art.Unidades if art else 0} unitats de '{article}'. Quantes en vols? üòä")
            pending_orders[chat_id] = article

    # 'confirm' i 'cancel' gestionats per la IA mitjan√ßant message retornat


def send_telegram_message(chat_id, text):
    try:
        requests.post(TELEGRAM_URL, json={"chat_id": chat_id, "text": text})
    except Exception as e:
        logger.error("Error enviant missatge Telegram: %s", e)


def buscar_article(descripcio):
    try:
        return Article.objects.get(DescripcionArticulo__iexact=descripcio)
    except Article.DoesNotExist:
        return None


def actualitzar_unidades(article, quantitat):
    article.Unidades -= quantitat
    article.save()


def convert_ogg_to_wav(input_file, output_file):
    command = ['ffmpeg', '-y', '-i', input_file, '-ac', '1', '-ar', '16000', output_file]
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return result.returncode


def handle_voice_message(file_id):
    # Obtenir info de l'arxiu via HTTP
    resp_info = requests.get(TELEGRAM_GETFILE_URL, params={"file_id": file_id})
    if resp_info.status_code != 200:
        return None, "Error obtenint informaci√≥ de l'√†udio"
    info = resp_info.json().get('result', {})
    path = info.get('file_path')
    if not path:
        return None, "Error obtenint ruta de l'√†udio"
    download_url = f"https://api.telegram.org/file/bot{TELEGRAM_TOKEN}/{path}"

    os.makedirs('temp', exist_ok=True)
    ogg_path, wav_path = f"temp/{file_id}.ogg", f"temp/{file_id}.wav"

    resp = requests.get(download_url)
    if not resp.ok or not resp.content:
        return None, "Error descarregant √†udio"
    with open(ogg_path, 'wb') as f:
        f.write(resp.content)

    if convert_ogg_to_wav(ogg_path, wav_path) != 0:
        os.remove(ogg_path)
        return None, "Error convertint √†udio"

    transcription, language = transcribe_audio(wav_path)
    os.remove(ogg_path)
    os.remove(wav_path)
    return transcription, language
